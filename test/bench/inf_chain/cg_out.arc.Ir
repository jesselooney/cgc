--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cg_out.arc --show=Ir
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         33554432 B, 64 B, direct-mapped
Command:          bin/ARC
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir_____________________ 

21,130,224,396 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir____________________________  file:function

< 11,590,028,763 (54.9%,  54.9%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h:
   1,920,000,000  (9.1%)            _alloc_log2_ceil
   1,280,000,000  (6.1%)            get_block_id
   1,150,000,000  (5.4%)            alloc_is_heap_ptr
   1,120,000,009  (5.3%)            alloc_new
   1,120,000,000  (5.3%)            get_pool
     960,000,000  (4.5%)            alloc_del_by_id
     880,000,000  (4.2%)            get_start_of_block
     780,000,000  (3.7%)            get_block_by_id
     640,000,000  (3.0%)            _alloc_clear_free_bit
     460,000,000  (2.2%)            alloc_del
     460,000,000  (2.2%)            _alloc_set_free_bit_by_id
     420,000,000  (2.0%)            clear_bit
     400,000,000  (1.9%)            set_bit

<  4,000,000,008 (18.9%,  73.8%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h:
   1,080,000,000  (5.1%)            _arc_is_heap_ptr
   1,000,000,000  (4.7%)            _arc_dec
     740,000,000  (3.5%)            arc_deregister
     520,000,000  (2.5%)            arc_alloc
     490,000,000  (2.3%)            arc_assign
     170,000,000  (0.8%)            _arc_inc

<  1,960,000,072  (9.3%,  83.1%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h:
   1,040,000,026  (4.9%)            stack_push
     920,000,023  (4.4%)            stack_pop

<  1,650,000,069  (7.8%,  90.9%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h:
     440,000,011  (2.1%)            _ptr_stack_pop
     430,000,013  (2.0%)            ptr_stack_scope_end
     420,000,000  (2.0%)            ptr_stack_push
     360,000,036  (1.7%)            ptr_stack_scope_start

<  1,190,006,040  (5.6%,  96.5%)  /home/madi/cosc490/cgc/test/bench/inf_chain/main.c:
     790,000,000  (3.7%)            iterate
     280,000,000  (1.3%)            list_t__map_ptrs
     120,006,040  (0.6%)            main

<    320,024,022  (1.5%,  98.0%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h:
     320,000,000  (1.5%)            monitor_write_heapstate

<    240,000,026  (1.1%,  99.1%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<    140,000,020  (0.7%,  99.8%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h:
     140,000,000  (0.7%)            cgc_free

<     40,000,197  (0.2%, 100.0%)  ???:
      40,000,185  (0.2%)            ???

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir__________________________  function:file

> 1,920,000,000 (9.1%,   9.1%)  _alloc_log2_ceil:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,280,000,000 (6.1%,  15.1%)  get_block_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,150,000,000 (5.4%,  20.6%)  alloc_is_heap_ptr:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,120,000,009 (5.3%,  25.9%)  alloc_new:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,120,000,000 (5.3%,  31.2%)  get_pool:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,080,000,000 (5.1%,  36.3%)  _arc_is_heap_ptr:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

> 1,040,000,026 (4.9%,  41.2%)  stack_push:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h

> 1,000,000,000 (4.7%,  46.0%)  _arc_dec:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   960,000,000 (4.5%,  50.5%)  alloc_del_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   920,000,023 (4.4%,  54.9%)  stack_pop:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h

>   880,000,000 (4.2%,  59.0%)  get_start_of_block:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   790,000,000 (3.7%,  62.8%)  iterate:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>   780,000,000 (3.7%,  66.4%)  get_block_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   740,000,000 (3.5%,  69.9%)  arc_deregister:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   640,000,000 (3.0%,  73.0%)  _alloc_clear_free_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   520,000,000 (2.5%,  75.4%)  arc_alloc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   490,000,000 (2.3%,  77.8%)  arc_assign:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   460,000,000 (2.2%,  79.9%)  alloc_del:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   460,000,000 (2.2%,  82.1%)  _alloc_set_free_bit_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   440,000,011 (2.1%,  84.2%)  _ptr_stack_pop:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   430,000,013 (2.0%,  86.2%)  ptr_stack_scope_end:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   420,000,000 (2.0%,  88.2%)  ptr_stack_push:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   420,000,000 (2.0%,  90.2%)  clear_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   400,000,000 (1.9%,  92.1%)  set_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   360,000,036 (1.7%,  93.8%)  ptr_stack_scope_start:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   320,000,000 (1.5%,  95.3%)  monitor_write_heapstate:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h

>   280,000,000 (1.3%,  96.6%)  list_t__map_ptrs:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>   240,000,026 (1.1%,  97.8%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>   170,000,000 (0.8%,  98.6%)  _arc_inc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   140,000,000 (0.7%,  99.2%)  cgc_free:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h

>   120,006,040 (0.6%,  99.8%)  main:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>    40,000,185 (0.2%, 100.0%)  ???:???

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h
--------------------------------------------------------------------------------
Ir__________________ 

-- line 80 ----------------------------------------
            .         //===============================================
            .         // Definitions
            .         //===============================================
            .         
            .         //  alloc_init()
            .         //      initialize a giant slab of memory for us to parse up. start the heap at the first 
            .         //      pool aligned address and bump the top up from there
            .         void alloc_init()
            4 (0.0%)  {
            .             log_info("alloc_init()");
            .         
            4 (0.0%)      const char *env_pool_exp = getenv("CGC_POOL_EXP");
            2 (0.0%)      if (env_pool_exp == NULL) {
            2 (0.0%)          ALLOC_POOL_SIZE_EXP = 16;
            .             } else {
            .                 ALLOC_POOL_SIZE_EXP = atoi(env_pool_exp);
            .             }
            .         
            4 (0.0%)      const char *env_heap_exp = getenv("CGC_HEAP_EXP");
            2 (0.0%)      if (env_pool_exp == NULL) {
            2 (0.0%)          ALLOC_HEAP_SIZE_EXP = 30;
            .             } else {
            .                 ALLOC_HEAP_SIZE_EXP = atoi(env_heap_exp);
            .             }
            .         
            4 (0.0%)      assert(ALLOC_POOL_SIZE_EXP <= ALLOC_HEAP_SIZE_EXP);
            .         
            7 (0.0%)      ALLOC_POOL_SIZE = 1 << ALLOC_POOL_SIZE_EXP;
            7 (0.0%)      ALLOC_HEAP_SIZE = 1 << ALLOC_HEAP_SIZE_EXP;
            1 (0.0%)      ALLOC_MIN_BLOCK_COUNT_EXP = 3;
            1 (0.0%)      ALLOC_MAX_BLOCK_COUNT_EXP = 6;
            1 (0.0%)      ALLOC_MIN_BLOCK_SIZE_EXP = 5;
            1 (0.0%)      ALLOC_MAX_BLOCK_SIZE_EXP =
            3 (0.0%)          ALLOC_POOL_SIZE_EXP - ALLOC_MIN_BLOCK_COUNT_EXP;
            .         
            9 (0.0%)      void *ptr = mmap(NULL, ALLOC_HEAP_SIZE, PROT_READ | PROT_WRITE,
            .                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
            .         
            2 (0.0%)      if (ptr == MAP_FAILED) {
            .                 log_error("call to mmap failed with errno == %d", errno);
            .                 exit(errno);
            .             }
            .         
            .             log_debug("ptr == %p", (void *) ptr);
            1 (0.0%)      ALLOC_HEAP_START =
            2 (0.0%)          (void *) (ptr +
            9 (0.0%)                    (ALLOC_POOL_SIZE - ((intptr_t) ptr % ALLOC_POOL_SIZE)));
            2 (0.0%)      ALLOC_HEAP_TOP = ALLOC_HEAP_START;
            .             log_debug("ALLOC_HEAP_START == ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
            .             log_info("alloc_init() == void");
            3 (0.0%)  }
            .         
            .         //  alloc_new(size_t)
            .         //      allocate memory
            .         //      rounded up to occupy a block of the next power of 2 size
            .         void *alloc_new(size_t size)
  100,000,000 (0.5%)  {
            .             log_info("alloc_new(%ld)", size);
   80,000,000 (0.4%)      _log2_ceil_return_t log2_ceil = _alloc_log2_ceil(size);
   40,000,000 (0.2%)      int index = log2_ceil.exp;
   40,000,000 (0.2%)      int block_size = log2_ceil.pow;
            .             log_debug("index == %d", index);
            .             log_debug("block_size == %d", block_size);
            .         
            .             // if smaller than smallest block, over-allocate in the smallest block size
   60,000,000 (0.3%)      if (index < ALLOC_MIN_BLOCK_SIZE_EXP) {
            .                 index = ALLOC_MIN_BLOCK_SIZE_EXP;
            .                 log_info("block size too small; clamping index to %d", index);
            .             }
            .             // Fail if requested size is larger than the largest size class.
   60,000,000 (0.3%)      if (index > ALLOC_MAX_BLOCK_SIZE_EXP) {
            .                 log_info("block size too large; returning NULL");
            .                 // TODO: Add large object handling. 
            .                 return NULL;
            .             }
            .             // Get the next block in the free list for this size class.
  120,000,000 (0.6%)      block_t *block = ALLOC_FREE_LISTS[index];
            .         
            .             // If there is no next block, create one by allocating a pool.
   40,000,000 (0.2%)      if (block == NULL) {
            .                 log_info("no free block in size class; allocating a new pool");
            5 (0.0%)          void *head_block = _alloc_new_pool(block_size);
            2 (0.0%)          if (head_block == NULL) {
            .                     log_info("failed to allocate new pool");
            .                     log_info("alloc_new(...) == NULL");
            .                     return NULL;        // Failed to allocate the pool.
            .                 }
            2 (0.0%)          block = head_block;
            .             }
            .             log_debug("block == %p", block);
            .         
            .             // Pull `block` off the free list.
   60,000,000 (0.3%)      block_t *next_block = *((block_t **) block);
            .             log_debug("next_block == %p", next_block);
  120,000,000 (0.6%)      ALLOC_FREE_LISTS[index] = next_block;
            .         
            .             // Initialize the block's memory for safety.
  120,000,000 (0.6%)      memset(block, 0, block_size);
            .         
            .             // Mark `block` as occupied.
   60,000,000 (0.3%)      _alloc_clear_free_bit(block);
            .         
            .             // mon ============
   60,000,000 (0.3%)      ALLOC_ALLOCATED_BLOCKS += 1;
  100,000,000 (0.5%)      ALLOC_ALLOCATED_BYTES += block_size;
            .             // mon ============
            .         
            .             log_info("alloc_new(...) == %p", block);
   20,000,000 (0.1%)      return block;
   40,000,000 (0.2%)  }
            .         
            .         void alloc_del(block_t *block)
  100,000,000 (0.5%)  {
            .             log_info("alloc_del(%p)", block);
            .         
   80,000,000 (0.4%)      pool_t *pool = get_pool(block);
  120,000,000 (0.6%)      size_t block_id = get_block_id(pool, block);
  100,000,000 (0.5%)      alloc_del_by_id(pool, block_id);
            .         
            .             log_info("alloc_del(...) == void");
   60,000,000 (0.3%)  }
            .         
            .         void alloc_del_by_id(pool_t *pool, size_t block_id)
  120,000,000 (0.6%)  {
            .             log_info("alloc_del_by_id(%p, %lu)", pool, block_id);
            .         
  120,000,000 (0.6%)      void *block = (void *) get_block_by_id(pool, block_id);
  100,000,000 (0.5%)      _alloc_set_free_bit_by_id(pool, block_id);
            .         
            .             // Get the index of the free list `block` belongs in.
  100,000,000 (0.5%)      _log2_ceil_return_t log2_ceil = _alloc_log2_ceil(pool->block_size);
   40,000,000 (0.2%)      int index = log2_ceil.exp;
            .         
            .             // Insert `block` at the front of the correct free list.
  140,000,000 (0.7%)      *((void **) block) = ALLOC_FREE_LISTS[index];
  120,000,000 (0.6%)      ALLOC_FREE_LISTS[index] = block;
            .         
            .             // mon ============
   60,000,000 (0.3%)      ALLOC_ALLOCATED_BLOCKS -= 1;
  100,000,000 (0.5%)      ALLOC_ALLOCATED_BYTES -= pool->block_size;
            .             // mon ============
            .         
            .             log_info("alloc_del_by_id(...) == void");
   60,000,000 (0.3%)  }
            .         
            .         bool alloc_get_mark_bit(void *block)
            .         {
            .             log_info("alloc_get_mark_bit(%p)", block);
            .         
            .             pool_t *pool = get_pool(block);
            .             size_t block_id = get_block_id(pool, block);
            .             uint8_t resident_byte =
-- line 231 ----------------------------------------
-- line 248 ----------------------------------------
            .             size_t block_id = get_block_id(pool, block);
            .             uint8_t *resident_byte =
            .                 &pool->data[bitvec_size(pool->block_size) + (block_id / 8)];
            .             set_bit(resident_byte, block_id % 8);
            .             log_info("alloc_set_mark_bit(...) == void");
            .         }
            .         
            .         bool alloc_is_heap_ptr(void *ptr)
  360,000,000 (1.7%)  {
  610,000,000 (2.9%)      return ALLOC_HEAP_START <= ptr && ptr < ALLOC_HEAP_TOP;
  180,000,000 (0.9%)  }
            .         
            .         //  _alloc_new_pool(size_t)
            .         //      if the ll of blocks in a size class is empty, we need to initialize a new set of 
            .         //      blocks in a new pool. 
            .         //      return NULL if no pool could be allocated
            .         //      return a pointer to the block at the head of the linked list of blocks on success
            .         static void *_alloc_new_pool(size_t block_size)
            5 (0.0%)  {
            .             log_info("_alloc_new_pool(%ld)", block_size);
            .         
            .             log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
            .             log_debug("ALLOC_POOL_SIZE == %ld", ALLOC_POOL_SIZE);
            .             log_debug("ALLOC_HEAP_START == %p", ALLOC_HEAP_START);
            .             log_debug("ALLOC_HEAP_SIZE == %ld", ALLOC_HEAP_SIZE);
            5 (0.0%)      if (ALLOC_HEAP_TOP + ALLOC_POOL_SIZE >
            3 (0.0%)          ALLOC_HEAP_START + ALLOC_HEAP_SIZE) {
            .                 log_info("cannot allocate new pool");
            .                 log_info("_alloc_new_pool(...) == NULL");
            .                 return NULL;
            .             }
            .         
            2 (0.0%)      pool_t *pool = (pool_t *) ALLOC_HEAP_TOP;
            4 (0.0%)      ALLOC_HEAP_TOP += ALLOC_POOL_SIZE;
            .             log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
            .         
            3 (0.0%)      pool->block_size = block_size;
            .             log_debug("pool == %p", pool);
            .             log_debug("pool->block_size == %ld", pool->block_size);
            .         
            .             // Set all the free bits. This includes the bits corresponding to blocks
            .             // this header occupies. Since we never add those to the free list, this
            .             // ensures they will never be touched in any way hereafter.
            3 (0.0%)      log_debug("bitvec_size(block_size) == %ld", bitvec_size(block_size));
            9 (0.0%)      memset(pool->data, ~0, bitvec_size(block_size));
            .         
            2 (0.0%)      void *pool_start = pool;
            4 (0.0%)      void *pool_end = pool_start + ALLOC_POOL_SIZE;
            6 (0.0%)      void *pool_header_end = pool_start + header_size(block_size);
            1 (0.0%)      void *prev = NULL;
            4 (0.0%)      void *block = pool_start + block_size;
            .             log_info("dividing pool into blocks");
            .             log_debug("pool_end == %p", pool_end);
            .             log_debug("pool_header_end == %p", pool_header_end);
       10,239 (0.0%)      for (; block < pool_end; block += block_size) {
        6,141 (0.0%)          if (block < pool_header_end) {
           16 (0.0%)              continue;
            .                 }
            .         
        6,093 (0.0%)          *((void **) block) = prev;
        6,093 (0.0%)          prev = block;
            .             }
            .         
            .             log_info("_alloc_new_pool(...) == %p", prev);
            3 (0.0%)      ALLOC_ALLOCATED_POOLS += 1;
            1 (0.0%)      return prev;
            2 (0.0%)  }
            .         
            .         static void _alloc_set_free_bit_by_id(pool_t *pool, size_t block_id)
  120,000,000 (0.6%)  {
  140,000,000 (0.7%)      uint8_t *resident_byte = &pool->data[block_id / 8];
  140,000,000 (0.7%)      set_bit(resident_byte, block_id % 8);
   60,000,000 (0.3%)  }
            .         
            .         static void _alloc_clear_free_bit(block_t *block)
  100,000,000 (0.5%)  {
            .             log_info("_alloc_clear_free_bit(%p)", block);
            .         
   80,000,000 (0.4%)      pool_t *pool = get_pool(block);
            .             log_debug("pool == %p", pool);
            .             log_debug("pool->block_size = %ld", pool->block_size);
            .         
  120,000,000 (0.6%)      size_t block_id = get_block_id(pool, block);
  140,000,000 (0.7%)      uint8_t *resident_byte = &pool->data[block_id / 8];
  140,000,000 (0.7%)      clear_bit(resident_byte, block_id % 8);
            .         
            .             log_info("_alloc_clear_free_bit(...) == void");
   60,000,000 (0.3%)  }
            .         
            .         // Quick and dirty method to find the smallest number pow such that 2^pow >= size.
            .         // WARN: not actually guaranteed to work for all values of type size_t, since there
            .         // might be overflow issues.
            .         // TODO: Short circuit once pow gets too big.
            .         static _log2_ceil_return_t _alloc_log2_ceil(size_t size)
  160,000,000 (0.8%)  {
   40,000,000 (0.2%)      int exp = 0;
   40,000,000 (0.2%)      int pow = 1;
1,000,000,000 (4.7%)      while (pow < size) {
  200,000,000 (0.9%)          exp++;
  200,000,000 (0.9%)          pow *= 2;
            .             }
            .         
            .             _log2_ceil_return_t ret;
   80,000,000 (0.4%)      ret.exp = exp;
   80,000,000 (0.4%)      ret.pow = pow;
            .         
   40,000,000 (0.2%)      return ret;
   80,000,000 (0.4%)  }
            .         
            .         
            .         size_t bitvec_size(size_t block_size)
           12 (0.0%)  {
           12 (0.0%)      return ALLOC_POOL_SIZE / block_size / 8;
            6 (0.0%)  }
            .         
            .         size_t header_size(size_t block_size)
            5 (0.0%)  {
            5 (0.0%)      return sizeof(size_t) + 2 * bitvec_size(block_size);
            2 (0.0%)  }
            .         
            .         // Return the pool containing `p`, assuming `p` is in the heap.
            .         pool_t *get_pool(void *p)
  320,000,000 (1.5%)  {
            .             // TODO: use a mask instead of shifting twice
  640,000,000 (3.0%)      return (pool_t *) (((intptr_t) p >> ALLOC_POOL_SIZE_EXP) <<
            .                                ALLOC_POOL_SIZE_EXP);
  160,000,000 (0.8%)  }
            .         
            .         // Return the ID of the block in `pool` containing `p`, assuming `p` is in `pool`.
            .         size_t get_block_id(pool_t *pool, void *p)
  400,000,000 (1.9%)  {
  720,000,000 (3.4%)      return ((intptr_t) p - (intptr_t) pool) / pool->block_size;
  160,000,000 (0.8%)  }
            .         
            .         block_t *get_block_by_id(pool_t *pool, size_t block_id)
  300,000,000 (1.4%)  {
  360,000,000 (1.7%)      return (block_t *) (((intptr_t) pool) + (block_id * pool->block_size));
  120,000,000 (0.6%)  }
            .         
            .         // Return the (start of) the block containing `p`, assuming `p` is in the heap.
            .         block_t *get_start_of_block(void *p)
  200,000,000 (0.9%)  {
  160,000,000 (0.8%)      pool_t *pool = get_pool(p);
  240,000,000 (1.1%)      size_t block_id = get_block_id(pool, p);
  200,000,000 (0.9%)      return get_block_by_id(pool, block_id);
   80,000,000 (0.4%)  }
            .         
            .         int get_bit(uint8_t byte, int index)
            .         {
            .             return (byte >> index) & 1;
            .         }
            .         
            .         void set_bit(uint8_t *byte_ptr, int index)
  100,000,000 (0.5%)  {
  240,000,000 (1.1%)      *byte_ptr |= 1 << index;
   60,000,000 (0.3%)  }
            .         
            .         void clear_bit(uint8_t *byte_ptr, int index)
  100,000,000 (0.5%)  {
  260,000,000 (1.2%)      *byte_ptr &= ~(1 << index);
   60,000,000 (0.3%)  }
            .         
            .         
            .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 31 ----------------------------------------
          .         static void _arc_inc(void *p);
          .         static void _arc_dec(void *p);
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         void arc_init()
          3 (0.0%)  {
          .             log_info("arc_init()");
          2 (0.0%)      alloc_init();
          .             log_info("arc_init(...) == void");
          3 (0.0%)  }
          .         
          .         void arc_alloc(void **p, size_t size,
          .                        void (*map_ptrs)(void *, void(*f)(void *)))
140,000,000 (0.7%)  {
          .             log_info("arc_alloc(%p, %ld, %p)", p, size, map_ptrs);
100,000,000 (0.5%)      _arc_header_t *header = alloc_new(size + sizeof(_arc_header_t));
 40,000,000 (0.2%)      if (header == NULL) {
          .                 log_error("Failed to allocate a block of size %ld", size);
          .                 exit(1);
          .             }
          .         
 40,000,000 (0.2%)      header->ref_count = 1;
 60,000,000 (0.3%)      header->map_ptrs = map_ptrs;
          .         
 80,000,000 (0.4%)      *p = (void *) (header + 1);
          .             log_trace("a %p", *p);
          .             log_info("arc_alloc(...) == void");
 60,000,000 (0.3%)  }
          .         
          .         void arc_assign(void **p, void *q)
120,000,000 (0.6%)  {
          .             log_info("arc_assign(%p, %p)", p, q);
          .             // Increment before decrementing because decrementing is potentially
          .             // destructive: arc_assign(&p, p) could fail if the order were reversed.
100,000,000 (0.5%)      if (_arc_is_heap_ptr(q))
 30,000,000 (0.1%)          _arc_inc(q);
120,000,000 (0.6%)      if (_arc_is_heap_ptr(*p))
          .                 _arc_dec(*p);
          .         
 60,000,000 (0.3%)      *p = q;
          .         
          .             log_info("arc_assign(...) == void");
 60,000,000 (0.3%)  }
          .         
          .         void arc_register(void *p)
          .         {
          .             log_info("arc_register(%p)", p);
          .             if (_arc_is_heap_ptr(p))
          .                 _arc_inc(p);
          .             log_info("arc_register(...) == void");
          .         }
          .         
          .         void arc_deregister(void *p)
250,000,000 (1.2%)  {
          .             log_info("arc_deregister(%p)", p);
250,000,000 (1.2%)      if (_arc_is_heap_ptr(p))
 90,000,000 (0.4%)          _arc_dec(p);
          .             log_info("arc_deregister(...) == void");
150,000,000 (0.7%)  }
          .         
          .         static _arc_header_t *_arc_get_header_ptr(void *p)
          .         {
          .             return (_arc_header_t *) p - 1;
          .         }
          .         
          .         static bool _arc_is_heap_ptr(void *p)
450,000,000 (2.1%)  {
          .             log_info("_arc_is_heap_ptr(%p)", p);
360,000,000 (1.7%)      bool ret = alloc_is_heap_ptr(p);
          .             log_info("_arc_is_heap_ptr(...) == %d", ret);
 90,000,000 (0.4%)      return ret;
180,000,000 (0.9%)  }
          .         
          .         static void _arc_inc(void *p)
 50,000,000 (0.2%)  {
          .             log_info("_arc_inc(%p)", p);
          .         
 40,000,000 (0.2%)      _arc_header_t *header = (_arc_header_t *) get_start_of_block(p);
 50,000,000 (0.2%)      header->ref_count++;
          .             log_debug("++ref_count == %lu", header->ref_count);
          .             log_info("_arc_inc(...) == void");
 30,000,000 (0.1%)  }
          .         
          .         static void _arc_dec(void *p)
150,000,000 (0.7%)  {
          .             log_info("_arc_dec(%p)", p);
          .         
120,000,000 (0.6%)      _arc_header_t *header = (_arc_header_t *) get_start_of_block(p);
          .             // The start of the "user object" containing `p`. That is, a pointer to the
          .             // start of the object as seen from the user's perspective, excluding our
          .             // metadata header.
 90,000,000 (0.4%)      void *obj = ((void *) header) + sizeof(_arc_header_t);
          .         
150,000,000 (0.7%)      header->ref_count--;
          .             log_debug("--ref_count == %lu", header->ref_count);
          .         
120,000,000 (0.6%)      if (header->ref_count == 0) {
          .                 log_info("no references remain; freeing block");
 80,000,000 (0.4%)          if (header->map_ptrs != NULL) {
          .                     log_debug("header->map_ptrs == %p", header->map_ptrs);
          .                     log_info("calling map_ptrs to deregister child pointers");
140,000,000 (0.7%)              (*header->map_ptrs) (obj, arc_deregister);
          .                     log_info("finished call to map_ptrs");
          .                 }
          .                 log_trace("f %p", obj);
 60,000,000 (0.3%)          alloc_del(header);
          .             }
          .         
          .             log_info("_arc_dec(...) = void");
 90,000,000 (0.4%)  }
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h
--------------------------------------------------------------------------------
Ir_______________ 

-- line 47 ----------------------------------------
         .             }\
         .         }
         .         
         .         // ==============================================
         .         // Definitions
         .         // ==============================================
         .         
         .         void cgc_free(void *p)
80,000,000 (0.4%)  {
         .             gc_free(p);
60,000,000 (0.3%)  }
         .         
         .         static void _cgc_init()
         3 (0.0%)  {
         2 (0.0%)      ptr_stack_init();
         2 (0.0%)      monitor_init();
         .         #ifdef GC_ARC
         2 (0.0%)      arc_init();
         .         #endif
         .         #ifdef GC_TRC
         .             trc_init();
         .         #endif
         .         #ifdef GC_NOP
         .             nop_init();
         .         #endif
         3 (0.0%)  }
         .         
         .         static void _cgc_end()
         3 (0.0%)  {
         2 (0.0%)      monitor_end();
         3 (0.0%)  }
         .         
         .         static void _cgc_collect()
         .         {
         .         #ifdef GC_TRC
         .             trc_collect();
         .         #endif
         .         }
         .         
-- line 85 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 38 ----------------------------------------
          .         size_t ALLOC_ALLOCATED_POOLS;
          .         size_t GC_TOTAL_PTR_ASSIGNS;
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         void monitor_init()
          4 (0.0%)  {
          4 (0.0%)      const char *outpath = getenv("CGC_OUTPATH");
          2 (0.0%)      if (outpath) {
          .                 enabled = true;
          .         
          .                 /////// open outpath
          .                 outfile = fopen(outpath, "w");
          .                 if (outfile == NULL) {
          .                     perror("death and bad (error opening outfile csv)");
          .                     exit(1);
          .                 }
-- line 56 ----------------------------------------
-- line 88 ----------------------------------------
          .                 assert(gc_select != NULL);
          .                 fprintf(outfile, "metadata,%s\n", gc_select);
          .                 ///////
          .         
          .                 /////// record start time
          .                 clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);
          .                 /////// 
          .             }
          3 (0.0%)  }
          .         
          .         void monitor_end()
          3 (0.0%)  {
          3 (0.0%)      if (enabled) {
          .                 fprintf(outfile, "%s", monitor_buffer);
          .                 fflush(outfile);
          .                 fclose(outfile);
          .             }
          3 (0.0%)  }
          .         
          .         // debugging thing basically
          .         void monitor_flush_buf()
          .         {
          .             fprintf(outfile, "%s", monitor_buffer);
          .             fflush(outfile);
          .             monitor_buffer_position = 0;
          .         }
-- line 113 ----------------------------------------
-- line 165 ----------------------------------------
          .         }
          .         
          .         void cgc_monitor_write_heapstate()
          .         {
          .             monitor_write_heapstate();
          .         }
          .         
          .         void monitor_write_heapstate()
120,000,000 (0.6%)  {
120,000,000 (0.6%)      if (enabled) {
          .                 // granularity
          .                 if (monitor_count_heapstate < monitor_granularity_heapstate) {
          .                     monitor_count_heapstate++;
          .                     return;
          .                 }
          .                 monitor_count_heapstate = 0;
          .         
          .                 // actually writing
          .         
          .                 _monitor_buffer_write("heapstate,%ld,%ld,%ld,%ld\n",
          .                                       ALLOC_ALLOCATED_BLOCKS,
          .                                       ALLOC_ALLOCATED_BYTES,
          .                                       ALLOC_ALLOCATED_POOLS, GC_TOTAL_PTR_ASSIGNS);
          .             }
 80,000,000 (0.4%)  }
          .         
          .         void cgc_monitor_write_user(char *line, ...)
     15,000 (0.0%)  {
      3,000 (0.0%)      if (enabled) {
          .                 va_list args;
          .                 va_start(args, line);
          .         
          .                 _monitor_buffer_vwrite(line, args);
          .         
          .                 va_end(args);
          .             }
      6,000 (0.0%)  }
          .         
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 25 ----------------------------------------
          .         
          .         static void **_ptr_stack_pop();
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         void ptr_stack_init()
          3 (0.0%)  {
          .             log_info("ptr_stack_init()");
          3 (0.0%)      PTR_STACK = stack_init(100);
          .             log_info("ptr_stack_init(...) == void");
          3 (0.0%)  }
          .         
          .         void ptr_stack_scope_start(int arg_count, ...)
150,000,015 (0.7%)  {
          .             log_trace("scope start");
          .             log_info("ptr_stack_scope_start(%d, ...)", arg_count);
          .         
          .             va_list args;
 60,000,006 (0.3%)      va_start(args, arg_count);
          .         
 40,000,004 (0.2%)      stack_push(PTR_STACK, PTR_STACK_SENTINEL);
 50,000,005 (0.2%)      for (int i = 0; i < arg_count; i++) {
          .                 void **p = va_arg(args, void **);
          .                 gc_register(*p);
          .                 ptr_stack_push(p);
          .             }
          .         
          .             va_end(args);
          .         
          .             log_info("ptr_stack_scope_start(...) == void");
 60,000,006 (0.3%)  }
          .         
          .         void ptr_stack_push(void **p)
150,000,000 (0.7%)  {
          .             log_info("ptr_stack_push(%p)", p);
          .         
 60,000,000 (0.3%)      if (p == PTR_STACK_SENTINEL) {
          .                 log_warn("Tried to push sentinel value onto PTR_STACK");
          .                 return;
          .             }
150,000,000 (0.7%)      stack_push(PTR_STACK, p);
          .         
          .             log_info("ptr_stack_push(...) == void");
 60,000,000 (0.3%)  }
          .         
          .         void ptr_stack_scope_end()
 40,000,004 (0.2%)  {
          .             log_trace("scope end");
          .             log_info("ptr_stack_scope_end()");
          .         
 30,000,000 (0.1%)      while (true) {
120,000,003 (0.6%)          void **p = _ptr_stack_pop();
 80,000,002 (0.4%)          if (p == PTR_STACK_SENTINEL)
 10,000,001 (0.0%)              break;
120,000,000 (0.6%)          gc_deregister(*p);
          .             }
          .         
          .             log_info("ptr_stack_scope_end(...) == void");
 30,000,003 (0.1%)  }
          .         
          .         static void **_ptr_stack_pop()
160,000,004 (0.8%)  {
          .             log_info("_ptr_stack_pop()");
          .         
160,000,004 (0.8%)      void **p = stack_pop(PTR_STACK);
          .         
          .             log_info("_ptr_stack_pop() == %p", p);
 40,000,001 (0.2%)      return p;
 80,000,002 (0.4%)  }
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 23 ----------------------------------------
          .         
          .         static void _stack_grow(stack_t * s);
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         stack_t *stack_init(size_t initial_size)
          5 (0.0%)  {
          3 (0.0%)      stack_t *s = malloc(sizeof(stack_t));
          .         
          3 (0.0%)      s->max_size = initial_size;
          2 (0.0%)      s->top = 0;
          7 (0.0%)      s->items = malloc(sizeof(void **) * initial_size);
          .         
          1 (0.0%)      return s;
          2 (0.0%)  }
          .         
          .         void stack_push(stack_t *s, void **p)
240,000,006 (1.1%)  {
240,000,006 (1.1%)      if (s->top == s->max_size)
          .                 _stack_grow(s);
440,000,011 (2.1%)      s->items[s->top++] = p;
120,000,003 (0.6%)  }
          .         
          .         void **stack_pop(stack_t *s)
200,000,005 (0.9%)  {
160,000,004 (0.8%)      if (s->top == 0) {
          .                 log_error("Tried to stack_pop with top == 0");
          .                 exit(1);
          .             }
480,000,012 (2.3%)      return s->items[--s->top];
 80,000,002 (0.4%)  }
          .         
          .         void stack_drop(stack_t *s)
          .         {
          .             free(s->items);
          .             free(s);
          .         }
          .         
          .         static void _stack_grow(stack_t *s)
-- line 63 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/main.c
--------------------------------------------------------------------------------
Ir________________ 

-- line 4 ----------------------------------------
          .         
          .         
          .         typedef struct list {
          .             int head;
          .             struct list *tail;
          .         } list_t;
          .         
          .         void list_t__map_ptrs(list_t *a, void (*f)(void *))
120,000,000 (0.6%)  {
100,000,000 (0.5%)      (*f) (a->tail);
 60,000,000 (0.3%)  }
          .         
 70,000,000 (0.3%)  void iterate() {
 60,000,000 (0.3%)      cgc_scope_start();
          .         
 40,000,000 (0.2%)      cgc_scope_declare(list_t *, a);
 70,000,000 (0.3%)      cgc_alloc(&a, list_t);
          .             
 40,000,000 (0.2%)      cgc_scope_declare(list_t*, b);
 70,000,000 (0.3%)      cgc_alloc(&b, list_t);
          .             
 40,000,000 (0.2%)      cgc_scope_declare(list_t*, c);
          .             //cgc_alloc(&c, list_t);
          .         
110,000,000 (0.5%)      cgc_assign(&a->tail, b);
110,000,000 (0.5%)      cgc_assign(&b->tail, c);
          .         
 60,000,000 (0.3%)      cgc_scope_end();
 30,000,000 (0.1%)      cgc_free(a);
 30,000,000 (0.1%)      cgc_free(b);
          .             //cgc_free(c);
 10,000,000 (0.0%)      return;
 50,000,000 (0.2%)  }
          .         
          7 (0.0%)  int main() {
          8 (0.0%)      cgc_scope_start();
          .         
          1 (0.0%)      int total_iterations  = 10000000;
          1 (0.0%)      int target_recordings = 1000;
          4 (0.0%)      int threshold = total_iterations / target_recordings;
          .         
 40,000,005 (0.2%)      for (int i = 0; i < total_iterations; i++) {
 20,000,000 (0.1%)          iterate();
 60,000,000 (0.3%)          if (i % threshold == 0) {
      6,000 (0.0%)              cgc_monitor_write_user("progress,%d\n", i);
          .                 }
          .             }
          8 (0.0%)      cgc_scope_end();
          1 (0.0%)      return 0;
          5 (0.0%)  

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir____________________ 

20,850,058,994 (98.7%)    annotated: files known & above threshold & readable, line numbers known
             0            annotated: files known & above threshold & readable, line numbers unknown
             0          unannotated: files known & above threshold & two or more non-identical
   240,000,026  (1.1%)  unannotated: files known & above threshold & unreadable 
       165,179  (0.0%)  unannotated: files known & below threshold
    40,000,197  (0.2%)  unannotated: files unknown

