--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate --diff cg_out.arc cg_out.trc --show=Ir
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         33554432 B, 64 B, direct-mapped
Command 1:        bin/ARC
Command 2:        bin/TRC
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir______________________ 

-11,507,213,854 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir____________________________  file:function

< -7,567,489,570 (65.8%,  65.8%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h:
  -1,150,000,000 (10.0%)            alloc_is_heap_ptr
    -960,000,000  (8.3%)            alloc_del_by_id
    -960,000,000  (8.3%)            _alloc_log2_ceil
    -960,000,000  (8.3%)            get_block_id
    -880,000,000  (7.6%)            get_start_of_block
    -840,000,000  (7.3%)            get_pool
    -780,000,000  (6.8%)            get_block_by_id
    -460,000,000  (4.0%)            alloc_del
    -460,000,000  (4.0%)            _alloc_set_free_bit_by_id
    -400,000,000  (3.5%)            set_bit
     282,008,233 (-2.5%)            _alloc_new_pool

< -4,000,000,008 (34.8%, 100.5%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h:
  -1,080,000,000  (9.4%)            _arc_is_heap_ptr
  -1,000,000,000  (8.7%)            _arc_dec
    -740,000,000  (6.4%)            arc_deregister
    -520,000,000  (4.5%)            arc_alloc
    -490,000,000  (4.3%)            arc_assign
    -170,000,000  (1.5%)            _arc_inc

<    520,000,008 (-4.5%,  96.0%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h:
     520,000,000 (-4.5%)            trc_alloc

<   -340,000,000  (3.0%,  99.0%)  /home/madi/cosc490/cgc/test/bench/inf_chain/main.c:
    -280,000,000  (2.4%)            list_t__map_ptrs
     -60,000,000  (0.5%)            iterate

<   -120,000,000  (1.0%, 100.0%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h:
    -120,000,000  (1.0%)            ptr_stack_scope_end

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir____________________________  function:file

> -1,150,000,000 (10.0%,  10.0%)  alloc_is_heap_ptr:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> -1,080,000,000  (9.4%,  19.4%)  _arc_is_heap_ptr:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

> -1,000,000,000  (8.7%,  28.1%)  _arc_dec:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   -960,000,000  (8.3%,  36.4%)  alloc_del_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -960,000,000  (8.3%,  44.8%)  _alloc_log2_ceil:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -960,000,000  (8.3%,  53.1%)  get_block_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -880,000,000  (7.6%,  60.7%)  get_start_of_block:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -840,000,000  (7.3%,  68.0%)  get_pool:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -780,000,000  (6.8%,  74.8%)  get_block_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -740,000,000  (6.4%,  81.3%)  arc_deregister:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   -520,000,000  (4.5%,  85.8%)  arc_alloc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>    520,000,000 (-4.5%,  81.3%)  trc_alloc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h

>   -490,000,000  (4.3%,  85.5%)  arc_assign:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   -460,000,000  (4.0%,  89.5%)  alloc_del:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -460,000,000  (4.0%,  93.5%)  _alloc_set_free_bit_by_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -400,000,000  (3.5%,  97.0%)  set_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>    282,008,233 (-2.5%,  94.5%)  _alloc_new_pool:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   -280,000,000  (2.4%,  97.0%)  list_t__map_ptrs:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>   -170,000,000  (1.5%,  98.4%)  _arc_inc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h

>   -120,000,000  (1.0%,  99.5%)  ptr_stack_scope_end:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>    -60,000,000  (0.5%, 100.0%)  iterate:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h
--------------------------------------------------------------------------------
Ir__________________ 

-- line 80 ----------------------------------------
           .          //===============================================
           .          // Definitions
           .          //===============================================
           .          
           .          //  alloc_init()
           .          //      initialize a giant slab of memory for us to parse up. start the heap at the first 
           .          //      pool aligned address and bump the top up from there
           .          void alloc_init()
           0          {
           .              log_info("alloc_init()");
           .          
           0              const char *env_pool_exp = getenv("CGC_POOL_EXP");
           0              if (env_pool_exp == NULL) {
           0                  ALLOC_POOL_SIZE_EXP = 16;
           .              } else {
           .                  ALLOC_POOL_SIZE_EXP = atoi(env_pool_exp);
           .              }
           .          
           0              const char *env_heap_exp = getenv("CGC_HEAP_EXP");
           0              if (env_pool_exp == NULL) {
           0                  ALLOC_HEAP_SIZE_EXP = 30;
           .              } else {
           .                  ALLOC_HEAP_SIZE_EXP = atoi(env_heap_exp);
           .              }
           .          
           0              assert(ALLOC_POOL_SIZE_EXP <= ALLOC_HEAP_SIZE_EXP);
           .          
           0              ALLOC_POOL_SIZE = 1 << ALLOC_POOL_SIZE_EXP;
           0              ALLOC_HEAP_SIZE = 1 << ALLOC_HEAP_SIZE_EXP;
           0              ALLOC_MIN_BLOCK_COUNT_EXP = 3;
           0              ALLOC_MAX_BLOCK_COUNT_EXP = 6;
           0              ALLOC_MIN_BLOCK_SIZE_EXP = 5;
           0              ALLOC_MAX_BLOCK_SIZE_EXP =
           0                  ALLOC_POOL_SIZE_EXP - ALLOC_MIN_BLOCK_COUNT_EXP;
           .          
           0              void *ptr = mmap(NULL, ALLOC_HEAP_SIZE, PROT_READ | PROT_WRITE,
           .                               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
           .          
           0              if (ptr == MAP_FAILED) {
           .                  log_error("call to mmap failed with errno == %d", errno);
           .                  exit(errno);
           .              }
           .          
           .              log_debug("ptr == %p", (void *) ptr);
           0              ALLOC_HEAP_START =
           0                  (void *) (ptr +
           0                            (ALLOC_POOL_SIZE - ((intptr_t) ptr % ALLOC_POOL_SIZE)));
           0              ALLOC_HEAP_TOP = ALLOC_HEAP_START;
           .              log_debug("ALLOC_HEAP_START == ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
           .              log_info("alloc_init() == void");
           0          }
           .          
           .          //  alloc_new(size_t)
           .          //      allocate memory
           .          //      rounded up to occupy a block of the next power of 2 size
           .          void *alloc_new(size_t size)
           0          {
           .              log_info("alloc_new(%ld)", size);
           0              _log2_ceil_return_t log2_ceil = _alloc_log2_ceil(size);
           0              int index = log2_ceil.exp;
           0              int block_size = log2_ceil.pow;
           .              log_debug("index == %d", index);
           .              log_debug("block_size == %d", block_size);
           .          
           .              // if smaller than smallest block, over-allocate in the smallest block size
           0              if (index < ALLOC_MIN_BLOCK_SIZE_EXP) {
           .                  index = ALLOC_MIN_BLOCK_SIZE_EXP;
           .                  log_info("block size too small; clamping index to %d", index);
           .              }
           .              // Fail if requested size is larger than the largest size class.
           0              if (index > ALLOC_MAX_BLOCK_SIZE_EXP) {
           .                  log_info("block size too large; returning NULL");
           .                  // TODO: Add large object handling. 
           .                  return NULL;
           .              }
           .              // Get the next block in the free list for this size class.
           0              block_t *block = ALLOC_FREE_LISTS[index];
           .          
           .              // If there is no next block, create one by allocating a pool.
           0              if (block == NULL) {
           .                  log_info("no free block in size class; allocating a new pool");
      49,235 (-0.0%)          void *head_block = _alloc_new_pool(block_size);
      19,694 (-0.0%)          if (head_block == NULL) {
           .                      log_info("failed to allocate new pool");
           .                      log_info("alloc_new(...) == NULL");
           .                      return NULL;        // Failed to allocate the pool.
           .                  }
      19,694 (-0.0%)          block = head_block;
           .              }
           .              log_debug("block == %p", block);
           .          
           .              // Pull `block` off the free list.
           0              block_t *next_block = *((block_t **) block);
           .              log_debug("next_block == %p", next_block);
           0              ALLOC_FREE_LISTS[index] = next_block;
           .          
           .              // Initialize the block's memory for safety.
           0              memset(block, 0, block_size);
           .          
           .              // Mark `block` as occupied.
           0              _alloc_clear_free_bit(block);
           .          
           .              // mon ============
           0              ALLOC_ALLOCATED_BLOCKS += 1;
           0              ALLOC_ALLOCATED_BYTES += block_size;
           .              // mon ============
           .          
           .              log_info("alloc_new(...) == %p", block);
           0              return block;
           0          }
           .          
           .          void alloc_del(block_t *block)
-100,000,000  (0.9%)  {
           .              log_info("alloc_del(%p)", block);
           .          
 -80,000,000  (0.7%)      pool_t *pool = get_pool(block);
-120,000,000  (1.0%)      size_t block_id = get_block_id(pool, block);
-100,000,000  (0.9%)      alloc_del_by_id(pool, block_id);
           .          
           .              log_info("alloc_del(...) == void");
 -60,000,000  (0.5%)  }
           .          
           .          void alloc_del_by_id(pool_t *pool, size_t block_id)
-120,000,000  (1.0%)  {
           .              log_info("alloc_del_by_id(%p, %lu)", pool, block_id);
           .          
-120,000,000  (1.0%)      void *block = (void *) get_block_by_id(pool, block_id);
-100,000,000  (0.9%)      _alloc_set_free_bit_by_id(pool, block_id);
           .          
           .              // Get the index of the free list `block` belongs in.
-100,000,000  (0.9%)      _log2_ceil_return_t log2_ceil = _alloc_log2_ceil(pool->block_size);
 -40,000,000  (0.3%)      int index = log2_ceil.exp;
           .          
           .              // Insert `block` at the front of the correct free list.
-140,000,000  (1.2%)      *((void **) block) = ALLOC_FREE_LISTS[index];
-120,000,000  (1.0%)      ALLOC_FREE_LISTS[index] = block;
           .          
           .              // mon ============
 -60,000,000  (0.5%)      ALLOC_ALLOCATED_BLOCKS -= 1;
-100,000,000  (0.9%)      ALLOC_ALLOCATED_BYTES -= pool->block_size;
           .              // mon ============
           .          
           .              log_info("alloc_del_by_id(...) == void");
 -60,000,000  (0.5%)  }
           .          
           .          bool alloc_get_mark_bit(void *block)
           .          {
           .              log_info("alloc_get_mark_bit(%p)", block);
           .          
           .              pool_t *pool = get_pool(block);
           .              size_t block_id = get_block_id(pool, block);
           .              uint8_t resident_byte =
-- line 231 ----------------------------------------
-- line 248 ----------------------------------------
           .              size_t block_id = get_block_id(pool, block);
           .              uint8_t *resident_byte =
           .                  &pool->data[bitvec_size(pool->block_size) + (block_id / 8)];
           .              set_bit(resident_byte, block_id % 8);
           .              log_info("alloc_set_mark_bit(...) == void");
           .          }
           .          
           .          bool alloc_is_heap_ptr(void *ptr)
-360,000,000  (3.1%)  {
-610,000,000  (5.3%)      return ALLOC_HEAP_START <= ptr && ptr < ALLOC_HEAP_TOP;
-180,000,000  (1.6%)  }
           .          
           .          //  _alloc_new_pool(size_t)
           .          //      if the ll of blocks in a size class is empty, we need to initialize a new set of 
           .          //      blocks in a new pool. 
           .          //      return NULL if no pool could be allocated
           .          //      return a pointer to the block at the head of the linked list of blocks on success
           .          static void *_alloc_new_pool(size_t block_size)
      49,235 (-0.0%)  {
           .              log_info("_alloc_new_pool(%ld)", block_size);
           .          
           .              log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
           .              log_debug("ALLOC_POOL_SIZE == %ld", ALLOC_POOL_SIZE);
           .              log_debug("ALLOC_HEAP_START == %p", ALLOC_HEAP_START);
           .              log_debug("ALLOC_HEAP_SIZE == %ld", ALLOC_HEAP_SIZE);
      49,235 (-0.0%)      if (ALLOC_HEAP_TOP + ALLOC_POOL_SIZE >
      29,541 (-0.0%)          ALLOC_HEAP_START + ALLOC_HEAP_SIZE) {
           .                  log_info("cannot allocate new pool");
           .                  log_info("_alloc_new_pool(...) == NULL");
           .                  return NULL;
           .              }
           .          
      19,694 (-0.0%)      pool_t *pool = (pool_t *) ALLOC_HEAP_TOP;
      39,388 (-0.0%)      ALLOC_HEAP_TOP += ALLOC_POOL_SIZE;
           .              log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
           .          
      29,541 (-0.0%)      pool->block_size = block_size;
           .              log_debug("pool == %p", pool);
           .              log_debug("pool->block_size == %ld", pool->block_size);
           .          
           .              // Set all the free bits. This includes the bits corresponding to blocks
           .              // this header occupies. Since we never add those to the free list, this
           .              // ensures they will never be touched in any way hereafter.
      29,541 (-0.0%)      log_debug("bitvec_size(block_size) == %ld", bitvec_size(block_size));
      88,623 (-0.0%)      memset(pool->data, ~0, bitvec_size(block_size));
           .          
      19,694 (-0.0%)      void *pool_start = pool;
      39,388 (-0.0%)      void *pool_end = pool_start + ALLOC_POOL_SIZE;
      59,082 (-0.0%)      void *pool_header_end = pool_start + header_size(block_size);
       9,847 (-0.0%)      void *prev = NULL;
      39,388 (-0.0%)      void *block = pool_start + block_size;
           .              log_info("dividing pool into blocks");
           .              log_debug("pool_end == %p", pool_end);
           .              log_debug("pool_header_end == %p", pool_header_end);
 100,823,433 (-0.9%)      for (; block < pool_end; block += block_size) {
  60,470,427 (-0.5%)          if (block < pool_header_end) {
     157,552 (-0.0%)              continue;
           .                  }
           .          
  59,997,771 (-0.5%)          *((void **) block) = prev;
  59,997,771 (-0.5%)          prev = block;
           .              }
           .          
           .              log_info("_alloc_new_pool(...) == %p", prev);
      29,541 (-0.0%)      ALLOC_ALLOCATED_POOLS += 1;
       9,847 (-0.0%)      return prev;
      19,694 (-0.0%)  }
           .          
           .          static void _alloc_set_free_bit_by_id(pool_t *pool, size_t block_id)
-120,000,000  (1.0%)  {
-140,000,000  (1.2%)      uint8_t *resident_byte = &pool->data[block_id / 8];
-140,000,000  (1.2%)      set_bit(resident_byte, block_id % 8);
 -60,000,000  (0.5%)  }
           .          
           .          static void _alloc_clear_free_bit(block_t *block)
           0          {
           .              log_info("_alloc_clear_free_bit(%p)", block);
           .          
           0              pool_t *pool = get_pool(block);
           .              log_debug("pool == %p", pool);
           .              log_debug("pool->block_size = %ld", pool->block_size);
           .          
           0              size_t block_id = get_block_id(pool, block);
           0              uint8_t *resident_byte = &pool->data[block_id / 8];
           0              clear_bit(resident_byte, block_id % 8);
           .          
           .              log_info("_alloc_clear_free_bit(...) == void");
           0          }
           .          
           .          // Quick and dirty method to find the smallest number pow such that 2^pow >= size.
           .          // WARN: not actually guaranteed to work for all values of type size_t, since there
           .          // might be overflow issues.
           .          // TODO: Short circuit once pow gets too big.
           .          static _log2_ceil_return_t _alloc_log2_ceil(size_t size)
 -80,000,000  (0.7%)  {
 -20,000,000  (0.2%)      int exp = 0;
 -20,000,000  (0.2%)      int pow = 1;
-500,000,000  (4.3%)      while (pow < size) {
-100,000,000  (0.9%)          exp++;
-100,000,000  (0.9%)          pow *= 2;
           .              }
           .          
           .              _log2_ceil_return_t ret;
 -40,000,000  (0.3%)      ret.exp = exp;
 -40,000,000  (0.3%)      ret.pow = pow;
           .          
 -20,000,000  (0.2%)      return ret;
 -40,000,000  (0.3%)  }
           .          
           .          
           .          size_t bitvec_size(size_t block_size)
     118,164 (-0.0%)  {
     118,164 (-0.0%)      return ALLOC_POOL_SIZE / block_size / 8;
      59,082 (-0.0%)  }
           .          
           .          size_t header_size(size_t block_size)
      49,235 (-0.0%)  {
      49,235 (-0.0%)      return sizeof(size_t) + 2 * bitvec_size(block_size);
      19,694 (-0.0%)  }
           .          
           .          // Return the pool containing `p`, assuming `p` is in the heap.
           .          pool_t *get_pool(void *p)
-240,000,000  (2.1%)  {
           .              // TODO: use a mask instead of shifting twice
-480,000,000  (4.2%)      return (pool_t *) (((intptr_t) p >> ALLOC_POOL_SIZE_EXP) <<
           .                                 ALLOC_POOL_SIZE_EXP);
-120,000,000  (1.0%)  }
           .          
           .          // Return the ID of the block in `pool` containing `p`, assuming `p` is in `pool`.
           .          size_t get_block_id(pool_t *pool, void *p)
-300,000,000  (2.6%)  {
-540,000,000  (4.7%)      return ((intptr_t) p - (intptr_t) pool) / pool->block_size;
-120,000,000  (1.0%)  }
           .          
           .          block_t *get_block_by_id(pool_t *pool, size_t block_id)
-300,000,000  (2.6%)  {
-360,000,000  (3.1%)      return (block_t *) (((intptr_t) pool) + (block_id * pool->block_size));
-120,000,000  (1.0%)  }
           .          
           .          // Return the (start of) the block containing `p`, assuming `p` is in the heap.
           .          block_t *get_start_of_block(void *p)
-200,000,000  (1.7%)  {
-160,000,000  (1.4%)      pool_t *pool = get_pool(p);
-240,000,000  (2.1%)      size_t block_id = get_block_id(pool, p);
-200,000,000  (1.7%)      return get_block_by_id(pool, block_id);
 -80,000,000  (0.7%)  }
           .          
           .          int get_bit(uint8_t byte, int index)
           .          {
           .              return (byte >> index) & 1;
           .          }
           .          
           .          void set_bit(uint8_t *byte_ptr, int index)
-100,000,000  (0.9%)  {
-240,000,000  (2.1%)      *byte_ptr |= 1 << index;
 -60,000,000  (0.5%)  }
           .          
           .          void clear_bit(uint8_t *byte_ptr, int index)
           0          {
           0              *byte_ptr &= ~(1 << index);
           0          }
           .          
           .          
           .          #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/arc.h
--------------------------------------------------------------------------------
Ir_________________ 

-- line 31 ----------------------------------------
           .         static void _arc_inc(void *p);
           .         static void _arc_dec(void *p);
           .         
           .         // ==============================================
           .         // Definitions
           .         // ==============================================
           .         
           .         void arc_init()
          -3 (0.0%)  {
           .             log_info("arc_init()");
          -2 (0.0%)      alloc_init();
           .             log_info("arc_init(...) == void");
          -3 (0.0%)  }
           .         
           .         void arc_alloc(void **p, size_t size,
           .                        void (*map_ptrs)(void *, void(*f)(void *)))
-140,000,000 (1.2%)  {
           .             log_info("arc_alloc(%p, %ld, %p)", p, size, map_ptrs);
-100,000,000 (0.9%)      _arc_header_t *header = alloc_new(size + sizeof(_arc_header_t));
 -40,000,000 (0.3%)      if (header == NULL) {
           .                 log_error("Failed to allocate a block of size %ld", size);
           .                 exit(1);
           .             }
           .         
 -40,000,000 (0.3%)      header->ref_count = 1;
 -60,000,000 (0.5%)      header->map_ptrs = map_ptrs;
           .         
 -80,000,000 (0.7%)      *p = (void *) (header + 1);
           .             log_trace("a %p", *p);
           .             log_info("arc_alloc(...) == void");
 -60,000,000 (0.5%)  }
           .         
           .         void arc_assign(void **p, void *q)
-120,000,000 (1.0%)  {
           .             log_info("arc_assign(%p, %p)", p, q);
           .             // Increment before decrementing because decrementing is potentially
           .             // destructive: arc_assign(&p, p) could fail if the order were reversed.
-100,000,000 (0.9%)      if (_arc_is_heap_ptr(q))
 -30,000,000 (0.3%)          _arc_inc(q);
-120,000,000 (1.0%)      if (_arc_is_heap_ptr(*p))
           .                 _arc_dec(*p);
           .         
 -60,000,000 (0.5%)      *p = q;
           .         
           .             log_info("arc_assign(...) == void");
 -60,000,000 (0.5%)  }
           .         
           .         void arc_register(void *p)
           .         {
           .             log_info("arc_register(%p)", p);
           .             if (_arc_is_heap_ptr(p))
           .                 _arc_inc(p);
           .             log_info("arc_register(...) == void");
           .         }
           .         
           .         void arc_deregister(void *p)
-250,000,000 (2.2%)  {
           .             log_info("arc_deregister(%p)", p);
-250,000,000 (2.2%)      if (_arc_is_heap_ptr(p))
 -90,000,000 (0.8%)          _arc_dec(p);
           .             log_info("arc_deregister(...) == void");
-150,000,000 (1.3%)  }
           .         
           .         static _arc_header_t *_arc_get_header_ptr(void *p)
           .         {
           .             return (_arc_header_t *) p - 1;
           .         }
           .         
           .         static bool _arc_is_heap_ptr(void *p)
-450,000,000 (3.9%)  {
           .             log_info("_arc_is_heap_ptr(%p)", p);
-360,000,000 (3.1%)      bool ret = alloc_is_heap_ptr(p);
           .             log_info("_arc_is_heap_ptr(...) == %d", ret);
 -90,000,000 (0.8%)      return ret;
-180,000,000 (1.6%)  }
           .         
           .         static void _arc_inc(void *p)
 -50,000,000 (0.4%)  {
           .             log_info("_arc_inc(%p)", p);
           .         
 -40,000,000 (0.3%)      _arc_header_t *header = (_arc_header_t *) get_start_of_block(p);
 -50,000,000 (0.4%)      header->ref_count++;
           .             log_debug("++ref_count == %lu", header->ref_count);
           .             log_info("_arc_inc(...) == void");
 -30,000,000 (0.3%)  }
           .         
           .         static void _arc_dec(void *p)
-150,000,000 (1.3%)  {
           .             log_info("_arc_dec(%p)", p);
           .         
-120,000,000 (1.0%)      _arc_header_t *header = (_arc_header_t *) get_start_of_block(p);
           .             // The start of the "user object" containing `p`. That is, a pointer to the
           .             // start of the object as seen from the user's perspective, excluding our
           .             // metadata header.
 -90,000,000 (0.8%)      void *obj = ((void *) header) + sizeof(_arc_header_t);
           .         
-150,000,000 (1.3%)      header->ref_count--;
           .             log_debug("--ref_count == %lu", header->ref_count);
           .         
-120,000,000 (1.0%)      if (header->ref_count == 0) {
           .                 log_info("no references remain; freeing block");
 -80,000,000 (0.7%)          if (header->map_ptrs != NULL) {
           .                     log_debug("header->map_ptrs == %p", header->map_ptrs);
           .                     log_info("calling map_ptrs to deregister child pointers");
-140,000,000 (1.2%)              (*header->map_ptrs) (obj, arc_deregister);
           .                     log_info("finished call to map_ptrs");
           .                 }
           .                 log_trace("f %p", obj);
 -60,000,000 (0.5%)          alloc_del(header);
           .             }
           .         
           .             log_info("_arc_dec(...) = void");
 -90,000,000 (0.8%)  }
           .         
           .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h
--------------------------------------------------------------------------------
Ir_________________ 

-- line 25 ----------------------------------------
           .         
           .         static void **_ptr_stack_pop();
           .         
           .         // ==============================================
           .         // Definitions
           .         // ==============================================
           .         
           .         void ptr_stack_init()
           0         {
           .             log_info("ptr_stack_init()");
           0             PTR_STACK = stack_init(100);
           .             log_info("ptr_stack_init(...) == void");
           0         }
           .         
           .         void ptr_stack_scope_start(int arg_count, ...)
           0         {
           .             log_trace("scope start");
           .             log_info("ptr_stack_scope_start(%d, ...)", arg_count);
           .         
           .             va_list args;
           0             va_start(args, arg_count);
           .         
           0             stack_push(PTR_STACK, PTR_STACK_SENTINEL);
           0             for (int i = 0; i < arg_count; i++) {
           .                 void **p = va_arg(args, void **);
           .                 gc_register(*p);
           .                 ptr_stack_push(p);
           .             }
           .         
           .             va_end(args);
           .         
           .             log_info("ptr_stack_scope_start(...) == void");
           0         }
           .         
           .         void ptr_stack_push(void **p)
           0         {
           .             log_info("ptr_stack_push(%p)", p);
           .         
           0             if (p == PTR_STACK_SENTINEL) {
           .                 log_warn("Tried to push sentinel value onto PTR_STACK");
           .                 return;
           .             }
           0             stack_push(PTR_STACK, p);
           .         
           .             log_info("ptr_stack_push(...) == void");
           0         }
           .         
           .         void ptr_stack_scope_end()
           0         {
           .             log_trace("scope end");
           .             log_info("ptr_stack_scope_end()");
           .         
           0             while (true) {
           0                 void **p = _ptr_stack_pop();
           0                 if (p == PTR_STACK_SENTINEL)
           0                     break;
-120,000,000 (1.0%)          gc_deregister(*p);
           .             }
           .         
           .             log_info("ptr_stack_scope_end(...) == void");
           0         }
           .         
           .         static void **_ptr_stack_pop()
           0         {
           .             log_info("_ptr_stack_pop()");
           .         
           0             void **p = stack_pop(PTR_STACK);
           .         
           .             log_info("_ptr_stack_pop() == %p", p);
           0             return p;
           0         }
           .         
           .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h
--------------------------------------------------------------------------------
Ir_________________ 

-- line 32 ----------------------------------------
          .          static void _trc_push_to_search_stack(void *p);
          .          
          .          // ==============================================
          .          // Definitions
          .          // ==============================================
          .          
          .          
          .          void trc_init()
          3 (-0.0%)  {
          2 (-0.0%)      alloc_init();
          3 (-0.0%)  }
          .          
          .          void trc_alloc(void **p, size_t size,
          .                         void (*map_ptrs)(void *, void(*f)(void *)))
140,000,000 (-1.2%)  {
 40,000,000 (-0.3%)      if (p == NULL) {
          .                  log_error
          .                      ("Passed NULL to trc_alloc (did you mean to pass &p instead of p?)");
          .                  exit(1);
          .              }
100,000,000 (-0.9%)      _trc_header_t *header = alloc_new(size + sizeof(intptr_t));
 40,000,000 (-0.3%)      if (header == NULL) {
          .                  trc_collect();
          .                  header = alloc_new(size + sizeof(intptr_t));
          .                  if (header == NULL) {
          .                      log_error("Failed to allocate a block of size %ld", size);
          .                      exit(1);
          .                  }
          .              }
 60,000,000 (-0.5%)      header->map_ptrs = map_ptrs;
 80,000,000 (-0.7%)      *p = header + 1;
          .              log_trace("a %p", *p);
 60,000,000 (-0.5%)  }
          .          
          .          void trc_collect()
          .          {
          .              _trc_mark();
          .              _trc_sweep();
          .          }
          .          
          .          // from the root set, dfs using map_ptrs 
-- line 72 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/main.c
--------------------------------------------------------------------------------
Ir_________________ 

-- line 4 ----------------------------------------
           .         
           .         
           .         typedef struct list {
           .             int head;
           .             struct list *tail;
           .         } list_t;
           .         
           .         void list_t__map_ptrs(list_t *a, void (*f)(void *))
-120,000,000 (1.0%)  {
-100,000,000 (0.9%)      (*f) (a->tail);
 -60,000,000 (0.5%)  }
           .         
           0         void iterate() {
           0             cgc_scope_start();
           .         
           0             cgc_scope_declare(list_t *, a);
           0             cgc_alloc(&a, list_t);
           .             
           0             cgc_scope_declare(list_t*, b);
           0             cgc_alloc(&b, list_t);
           .             
           0             cgc_scope_declare(list_t*, c);
           .             //cgc_alloc(&c, list_t);
           .         
 -30,000,000 (0.3%)      cgc_assign(&a->tail, b);
 -30,000,000 (0.3%)      cgc_assign(&b->tail, c);
           .         
           0             cgc_scope_end();
           0             cgc_free(a);
           0             cgc_free(b);
           .             //cgc_free(c);
           0             return;
           0         }
           .         
           0         int main() {
           0             cgc_scope_start();
           .         
           0             int total_iterations  = 10000000;
           0             int target_recordings = 1000;
           0             int threshold = total_iterations / target_recordings;
           .         
           0             for (int i = 0; i < total_iterations; i++) {
           0                 iterate();
           0                 if (i % threshold == 0) {
           0                     cgc_monitor_write_user("progress,%d\n", i);
           .                 }
           .             }
           0             cgc_scope_end();
           0             return 0;
           0         

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir______________________ 

-11,507,489,570 (100.0%)    annotated: files known & above threshold & readable, line numbers known
              0             annotated: files known & above threshold & readable, line numbers unknown
              0           unannotated: files known & above threshold & two or more non-identical
              0           unannotated: files known & above threshold & unreadable 
        256,022  (-0.0%)  unannotated: files known & below threshold
         19,694  (-0.0%)  unannotated: files unknown

