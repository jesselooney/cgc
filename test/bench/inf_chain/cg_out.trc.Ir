--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate --show=Ir cg_out.trc
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         33554432 B, 64 B, direct-mapped
Command:          bin/TRC
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir____________________ 

9,623,010,542 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir___________________________  file:function

< 4,022,539,193 (41.8%,  41.8%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h:
  1,120,088,632 (11.6%)            alloc_new
    960,000,000 (10.0%)            _alloc_log2_ceil
    640,000,000  (6.7%)            _alloc_clear_free_bit
    420,000,000  (4.4%)            clear_bit
    320,000,000  (3.3%)            get_block_id
    282,036,872  (2.9%)            _alloc_new_pool
    280,000,000  (2.9%)            get_pool

< 1,960,000,072 (20.4%,  62.2%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h:
  1,040,000,026 (10.8%)            stack_push
    920,000,023  (9.6%)            stack_pop

< 1,530,000,069 (15.9%,  78.1%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h:
    440,000,011  (4.6%)            _ptr_stack_pop
    420,000,000  (4.4%)            ptr_stack_push
    360,000,036  (3.7%)            ptr_stack_scope_start
    310,000,013  (3.2%)            ptr_stack_scope_end

<   850,006,040  (8.8%,  86.9%)  /home/madi/cosc490/cgc/test/bench/inf_chain/main.c:
    730,000,000  (7.6%)            iterate
    120,006,040  (1.2%)            main

<   520,000,008  (5.4%,  92.3%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h:
    520,000,000  (5.4%)            trc_alloc

<   320,024,022  (3.3%,  95.6%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h:
    320,000,000  (3.3%)            monitor_write_heapstate

<   240,256,048  (2.5%,  98.1%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<   140,000,020  (1.5%,  99.6%)  /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h:
    140,000,000  (1.5%)            cgc_free

<    40,019,891  (0.4%, 100.0%)  ???:
     40,019,879  (0.4%)            ???

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir___________________________  function:file

> 1,120,088,632 (11.6%,  11.6%)  alloc_new:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

> 1,040,000,026 (10.8%,  22.4%)  stack_push:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h

>   960,000,000 (10.0%,  32.4%)  _alloc_log2_ceil:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   920,000,023  (9.6%,  42.0%)  stack_pop:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h

>   730,000,000  (7.6%,  49.6%)  iterate:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>   640,000,000  (6.7%,  56.2%)  _alloc_clear_free_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   520,000,000  (5.4%,  61.6%)  trc_alloc:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h

>   440,000,011  (4.6%,  66.2%)  _ptr_stack_pop:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   420,000,000  (4.4%,  70.6%)  ptr_stack_push:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   420,000,000  (4.4%,  74.9%)  clear_bit:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   360,000,036  (3.7%,  78.7%)  ptr_stack_scope_start:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   320,000,000  (3.3%,  82.0%)  monitor_write_heapstate:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h

>   320,000,000  (3.3%,  85.3%)  get_block_id:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   310,000,013  (3.2%,  88.5%)  ptr_stack_scope_end:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h

>   282,036,872  (2.9%,  91.5%)  _alloc_new_pool:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   280,000,000  (2.9%,  94.4%)  get_pool:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h

>   240,256,048  (2.5%,  96.9%)  __memset_avx2_unaligned_erms:./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>   140,000,000  (1.5%,  98.3%)  cgc_free:/home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h

>   120,006,040  (1.2%,  99.6%)  main:/home/madi/cosc490/cgc/test/bench/inf_chain/main.c

>    40,019,879  (0.4%, 100.0%)  ???:???

--------------------------------------------------------------------------------
-- Annotated source file: ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/alloc.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 80 ----------------------------------------
          .         //===============================================
          .         // Definitions
          .         //===============================================
          .         
          .         //  alloc_init()
          .         //      initialize a giant slab of memory for us to parse up. start the heap at the first 
          .         //      pool aligned address and bump the top up from there
          .         void alloc_init()
          4 (0.0%)  {
          .             log_info("alloc_init()");
          .         
          4 (0.0%)      const char *env_pool_exp = getenv("CGC_POOL_EXP");
          2 (0.0%)      if (env_pool_exp == NULL) {
          2 (0.0%)          ALLOC_POOL_SIZE_EXP = 16;
          .             } else {
          .                 ALLOC_POOL_SIZE_EXP = atoi(env_pool_exp);
          .             }
          .         
          4 (0.0%)      const char *env_heap_exp = getenv("CGC_HEAP_EXP");
          2 (0.0%)      if (env_pool_exp == NULL) {
          2 (0.0%)          ALLOC_HEAP_SIZE_EXP = 30;
          .             } else {
          .                 ALLOC_HEAP_SIZE_EXP = atoi(env_heap_exp);
          .             }
          .         
          4 (0.0%)      assert(ALLOC_POOL_SIZE_EXP <= ALLOC_HEAP_SIZE_EXP);
          .         
          7 (0.0%)      ALLOC_POOL_SIZE = 1 << ALLOC_POOL_SIZE_EXP;
          7 (0.0%)      ALLOC_HEAP_SIZE = 1 << ALLOC_HEAP_SIZE_EXP;
          1 (0.0%)      ALLOC_MIN_BLOCK_COUNT_EXP = 3;
          1 (0.0%)      ALLOC_MAX_BLOCK_COUNT_EXP = 6;
          1 (0.0%)      ALLOC_MIN_BLOCK_SIZE_EXP = 5;
          1 (0.0%)      ALLOC_MAX_BLOCK_SIZE_EXP =
          3 (0.0%)          ALLOC_POOL_SIZE_EXP - ALLOC_MIN_BLOCK_COUNT_EXP;
          .         
          9 (0.0%)      void *ptr = mmap(NULL, ALLOC_HEAP_SIZE, PROT_READ | PROT_WRITE,
          .                              MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
          .         
          2 (0.0%)      if (ptr == MAP_FAILED) {
          .                 log_error("call to mmap failed with errno == %d", errno);
          .                 exit(errno);
          .             }
          .         
          .             log_debug("ptr == %p", (void *) ptr);
          1 (0.0%)      ALLOC_HEAP_START =
          2 (0.0%)          (void *) (ptr +
          9 (0.0%)                    (ALLOC_POOL_SIZE - ((intptr_t) ptr % ALLOC_POOL_SIZE)));
          2 (0.0%)      ALLOC_HEAP_TOP = ALLOC_HEAP_START;
          .             log_debug("ALLOC_HEAP_START == ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
          .             log_info("alloc_init() == void");
          3 (0.0%)  }
          .         
          .         //  alloc_new(size_t)
          .         //      allocate memory
          .         //      rounded up to occupy a block of the next power of 2 size
          .         void *alloc_new(size_t size)
100,000,000 (1.0%)  {
          .             log_info("alloc_new(%ld)", size);
 80,000,000 (0.8%)      _log2_ceil_return_t log2_ceil = _alloc_log2_ceil(size);
 40,000,000 (0.4%)      int index = log2_ceil.exp;
 40,000,000 (0.4%)      int block_size = log2_ceil.pow;
          .             log_debug("index == %d", index);
          .             log_debug("block_size == %d", block_size);
          .         
          .             // if smaller than smallest block, over-allocate in the smallest block size
 60,000,000 (0.6%)      if (index < ALLOC_MIN_BLOCK_SIZE_EXP) {
          .                 index = ALLOC_MIN_BLOCK_SIZE_EXP;
          .                 log_info("block size too small; clamping index to %d", index);
          .             }
          .             // Fail if requested size is larger than the largest size class.
 60,000,000 (0.6%)      if (index > ALLOC_MAX_BLOCK_SIZE_EXP) {
          .                 log_info("block size too large; returning NULL");
          .                 // TODO: Add large object handling. 
          .                 return NULL;
          .             }
          .             // Get the next block in the free list for this size class.
120,000,000 (1.2%)      block_t *block = ALLOC_FREE_LISTS[index];
          .         
          .             // If there is no next block, create one by allocating a pool.
 40,000,000 (0.4%)      if (block == NULL) {
          .                 log_info("no free block in size class; allocating a new pool");
     49,240 (0.0%)          void *head_block = _alloc_new_pool(block_size);
     19,696 (0.0%)          if (head_block == NULL) {
          .                     log_info("failed to allocate new pool");
          .                     log_info("alloc_new(...) == NULL");
          .                     return NULL;        // Failed to allocate the pool.
          .                 }
     19,696 (0.0%)          block = head_block;
          .             }
          .             log_debug("block == %p", block);
          .         
          .             // Pull `block` off the free list.
 60,000,000 (0.6%)      block_t *next_block = *((block_t **) block);
          .             log_debug("next_block == %p", next_block);
120,000,000 (1.2%)      ALLOC_FREE_LISTS[index] = next_block;
          .         
          .             // Initialize the block's memory for safety.
120,000,000 (1.2%)      memset(block, 0, block_size);
          .         
          .             // Mark `block` as occupied.
 60,000,000 (0.6%)      _alloc_clear_free_bit(block);
          .         
          .             // mon ============
 60,000,000 (0.6%)      ALLOC_ALLOCATED_BLOCKS += 1;
100,000,000 (1.0%)      ALLOC_ALLOCATED_BYTES += block_size;
          .             // mon ============
          .         
          .             log_info("alloc_new(...) == %p", block);
 20,000,000 (0.2%)      return block;
 40,000,000 (0.4%)  }
          .         
          .         void alloc_del(block_t *block)
          .         {
          .             log_info("alloc_del(%p)", block);
          .         
          .             pool_t *pool = get_pool(block);
          .             size_t block_id = get_block_id(pool, block);
          .             alloc_del_by_id(pool, block_id);
-- line 197 ----------------------------------------
-- line 258 ----------------------------------------
          .         }
          .         
          .         //  _alloc_new_pool(size_t)
          .         //      if the ll of blocks in a size class is empty, we need to initialize a new set of 
          .         //      blocks in a new pool. 
          .         //      return NULL if no pool could be allocated
          .         //      return a pointer to the block at the head of the linked list of blocks on success
          .         static void *_alloc_new_pool(size_t block_size)
     49,240 (0.0%)  {
          .             log_info("_alloc_new_pool(%ld)", block_size);
          .         
          .             log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
          .             log_debug("ALLOC_POOL_SIZE == %ld", ALLOC_POOL_SIZE);
          .             log_debug("ALLOC_HEAP_START == %p", ALLOC_HEAP_START);
          .             log_debug("ALLOC_HEAP_SIZE == %ld", ALLOC_HEAP_SIZE);
     49,240 (0.0%)      if (ALLOC_HEAP_TOP + ALLOC_POOL_SIZE >
     29,544 (0.0%)          ALLOC_HEAP_START + ALLOC_HEAP_SIZE) {
          .                 log_info("cannot allocate new pool");
          .                 log_info("_alloc_new_pool(...) == NULL");
          .                 return NULL;
          .             }
          .         
     19,696 (0.0%)      pool_t *pool = (pool_t *) ALLOC_HEAP_TOP;
     39,392 (0.0%)      ALLOC_HEAP_TOP += ALLOC_POOL_SIZE;
          .             log_debug("ALLOC_HEAP_TOP == %p", ALLOC_HEAP_TOP);
          .         
     29,544 (0.0%)      pool->block_size = block_size;
          .             log_debug("pool == %p", pool);
          .             log_debug("pool->block_size == %ld", pool->block_size);
          .         
          .             // Set all the free bits. This includes the bits corresponding to blocks
          .             // this header occupies. Since we never add those to the free list, this
          .             // ensures they will never be touched in any way hereafter.
     29,544 (0.0%)      log_debug("bitvec_size(block_size) == %ld", bitvec_size(block_size));
     88,632 (0.0%)      memset(pool->data, ~0, bitvec_size(block_size));
          .         
     19,696 (0.0%)      void *pool_start = pool;
     39,392 (0.0%)      void *pool_end = pool_start + ALLOC_POOL_SIZE;
     59,088 (0.0%)      void *pool_header_end = pool_start + header_size(block_size);
      9,848 (0.0%)      void *prev = NULL;
     39,392 (0.0%)      void *block = pool_start + block_size;
          .             log_info("dividing pool into blocks");
          .             log_debug("pool_end == %p", pool_end);
          .             log_debug("pool_header_end == %p", pool_header_end);
100,833,672 (1.0%)      for (; block < pool_end; block += block_size) {
 60,476,568 (0.6%)          if (block < pool_header_end) {
    157,568 (0.0%)              continue;
          .                 }
          .         
 60,003,864 (0.6%)          *((void **) block) = prev;
 60,003,864 (0.6%)          prev = block;
          .             }
          .         
          .             log_info("_alloc_new_pool(...) == %p", prev);
     29,544 (0.0%)      ALLOC_ALLOCATED_POOLS += 1;
      9,848 (0.0%)      return prev;
     19,696 (0.0%)  }
          .         
          .         static void _alloc_set_free_bit_by_id(pool_t *pool, size_t block_id)
          .         {
          .             uint8_t *resident_byte = &pool->data[block_id / 8];
          .             set_bit(resident_byte, block_id % 8);
          .         }
          .         
          .         static void _alloc_clear_free_bit(block_t *block)
100,000,000 (1.0%)  {
          .             log_info("_alloc_clear_free_bit(%p)", block);
          .         
 80,000,000 (0.8%)      pool_t *pool = get_pool(block);
          .             log_debug("pool == %p", pool);
          .             log_debug("pool->block_size = %ld", pool->block_size);
          .         
120,000,000 (1.2%)      size_t block_id = get_block_id(pool, block);
140,000,000 (1.5%)      uint8_t *resident_byte = &pool->data[block_id / 8];
140,000,000 (1.5%)      clear_bit(resident_byte, block_id % 8);
          .         
          .             log_info("_alloc_clear_free_bit(...) == void");
 60,000,000 (0.6%)  }
          .         
          .         // Quick and dirty method to find the smallest number pow such that 2^pow >= size.
          .         // WARN: not actually guaranteed to work for all values of type size_t, since there
          .         // might be overflow issues.
          .         // TODO: Short circuit once pow gets too big.
          .         static _log2_ceil_return_t _alloc_log2_ceil(size_t size)
 80,000,000 (0.8%)  {
 20,000,000 (0.2%)      int exp = 0;
 20,000,000 (0.2%)      int pow = 1;
500,000,000 (5.2%)      while (pow < size) {
100,000,000 (1.0%)          exp++;
100,000,000 (1.0%)          pow *= 2;
          .             }
          .         
          .             _log2_ceil_return_t ret;
 40,000,000 (0.4%)      ret.exp = exp;
 40,000,000 (0.4%)      ret.pow = pow;
          .         
 20,000,000 (0.2%)      return ret;
 40,000,000 (0.4%)  }
          .         
          .         
          .         size_t bitvec_size(size_t block_size)
    118,176 (0.0%)  {
    118,176 (0.0%)      return ALLOC_POOL_SIZE / block_size / 8;
     59,088 (0.0%)  }
          .         
          .         size_t header_size(size_t block_size)
     49,240 (0.0%)  {
     49,240 (0.0%)      return sizeof(size_t) + 2 * bitvec_size(block_size);
     19,696 (0.0%)  }
          .         
          .         // Return the pool containing `p`, assuming `p` is in the heap.
          .         pool_t *get_pool(void *p)
 80,000,000 (0.8%)  {
          .             // TODO: use a mask instead of shifting twice
160,000,000 (1.7%)      return (pool_t *) (((intptr_t) p >> ALLOC_POOL_SIZE_EXP) <<
          .                                ALLOC_POOL_SIZE_EXP);
 40,000,000 (0.4%)  }
          .         
          .         // Return the ID of the block in `pool` containing `p`, assuming `p` is in `pool`.
          .         size_t get_block_id(pool_t *pool, void *p)
100,000,000 (1.0%)  {
180,000,000 (1.9%)      return ((intptr_t) p - (intptr_t) pool) / pool->block_size;
 40,000,000 (0.4%)  }
          .         
          .         block_t *get_block_by_id(pool_t *pool, size_t block_id)
          .         {
          .             return (block_t *) (((intptr_t) pool) + (block_id * pool->block_size));
          .         }
          .         
          .         // Return the (start of) the block containing `p`, assuming `p` is in the heap.
          .         block_t *get_start_of_block(void *p)
-- line 388 ----------------------------------------
-- line 398 ----------------------------------------
          .         }
          .         
          .         void set_bit(uint8_t *byte_ptr, int index)
          .         {
          .             *byte_ptr |= 1 << index;
          .         }
          .         
          .         void clear_bit(uint8_t *byte_ptr, int index)
100,000,000 (1.0%)  {
260,000,000 (2.7%)      *byte_ptr &= ~(1 << index);
 60,000,000 (0.6%)  }
          .         
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/cgc.h
--------------------------------------------------------------------------------
Ir_______________ 

-- line 47 ----------------------------------------
         .             }\
         .         }
         .         
         .         // ==============================================
         .         // Definitions
         .         // ==============================================
         .         
         .         void cgc_free(void *p)
80,000,000 (0.8%)  {
         .             gc_free(p);
60,000,000 (0.6%)  }
         .         
         .         static void _cgc_init()
         3 (0.0%)  {
         2 (0.0%)      ptr_stack_init();
         2 (0.0%)      monitor_init();
         .         #ifdef GC_ARC
         .             arc_init();
         .         #endif
         .         #ifdef GC_TRC
         2 (0.0%)      trc_init();
         .         #endif
         .         #ifdef GC_NOP
         .             nop_init();
         .         #endif
         3 (0.0%)  }
         .         
         .         static void _cgc_end()
         3 (0.0%)  {
         2 (0.0%)      monitor_end();
         3 (0.0%)  }
         .         
         .         static void _cgc_collect()
         .         {
         .         #ifdef GC_TRC
         .             trc_collect();
         .         #endif
         .         }
         .         
-- line 85 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/monitor.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 38 ----------------------------------------
          .         size_t ALLOC_ALLOCATED_POOLS;
          .         size_t GC_TOTAL_PTR_ASSIGNS;
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         void monitor_init()
          4 (0.0%)  {
          4 (0.0%)      const char *outpath = getenv("CGC_OUTPATH");
          2 (0.0%)      if (outpath) {
          .                 enabled = true;
          .         
          .                 /////// open outpath
          .                 outfile = fopen(outpath, "w");
          .                 if (outfile == NULL) {
          .                     perror("death and bad (error opening outfile csv)");
          .                     exit(1);
          .                 }
-- line 56 ----------------------------------------
-- line 88 ----------------------------------------
          .                 assert(gc_select != NULL);
          .                 fprintf(outfile, "metadata,%s\n", gc_select);
          .                 ///////
          .         
          .                 /////// record start time
          .                 clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);
          .                 /////// 
          .             }
          3 (0.0%)  }
          .         
          .         void monitor_end()
          3 (0.0%)  {
          3 (0.0%)      if (enabled) {
          .                 fprintf(outfile, "%s", monitor_buffer);
          .                 fflush(outfile);
          .                 fclose(outfile);
          .             }
          3 (0.0%)  }
          .         
          .         // debugging thing basically
          .         void monitor_flush_buf()
          .         {
          .             fprintf(outfile, "%s", monitor_buffer);
          .             fflush(outfile);
          .             monitor_buffer_position = 0;
          .         }
-- line 113 ----------------------------------------
-- line 165 ----------------------------------------
          .         }
          .         
          .         void cgc_monitor_write_heapstate()
          .         {
          .             monitor_write_heapstate();
          .         }
          .         
          .         void monitor_write_heapstate()
120,000,000 (1.2%)  {
120,000,000 (1.2%)      if (enabled) {
          .                 // granularity
          .                 if (monitor_count_heapstate < monitor_granularity_heapstate) {
          .                     monitor_count_heapstate++;
          .                     return;
          .                 }
          .                 monitor_count_heapstate = 0;
          .         
          .                 // actually writing
          .         
          .                 _monitor_buffer_write("heapstate,%ld,%ld,%ld,%ld\n",
          .                                       ALLOC_ALLOCATED_BLOCKS,
          .                                       ALLOC_ALLOCATED_BYTES,
          .                                       ALLOC_ALLOCATED_POOLS, GC_TOTAL_PTR_ASSIGNS);
          .             }
 80,000,000 (0.8%)  }
          .         
          .         void cgc_monitor_write_user(char *line, ...)
     15,000 (0.0%)  {
      3,000 (0.0%)      if (enabled) {
          .                 va_list args;
          .                 va_start(args, line);
          .         
          .                 _monitor_buffer_vwrite(line, args);
          .         
          .                 va_end(args);
          .             }
      6,000 (0.0%)  }
          .         
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/ptr_stack.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 25 ----------------------------------------
          .         
          .         static void **_ptr_stack_pop();
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         void ptr_stack_init()
          3 (0.0%)  {
          .             log_info("ptr_stack_init()");
          3 (0.0%)      PTR_STACK = stack_init(100);
          .             log_info("ptr_stack_init(...) == void");
          3 (0.0%)  }
          .         
          .         void ptr_stack_scope_start(int arg_count, ...)
150,000,015 (1.6%)  {
          .             log_trace("scope start");
          .             log_info("ptr_stack_scope_start(%d, ...)", arg_count);
          .         
          .             va_list args;
 60,000,006 (0.6%)      va_start(args, arg_count);
          .         
 40,000,004 (0.4%)      stack_push(PTR_STACK, PTR_STACK_SENTINEL);
 50,000,005 (0.5%)      for (int i = 0; i < arg_count; i++) {
          .                 void **p = va_arg(args, void **);
          .                 gc_register(*p);
          .                 ptr_stack_push(p);
          .             }
          .         
          .             va_end(args);
          .         
          .             log_info("ptr_stack_scope_start(...) == void");
 60,000,006 (0.6%)  }
          .         
          .         void ptr_stack_push(void **p)
150,000,000 (1.6%)  {
          .             log_info("ptr_stack_push(%p)", p);
          .         
 60,000,000 (0.6%)      if (p == PTR_STACK_SENTINEL) {
          .                 log_warn("Tried to push sentinel value onto PTR_STACK");
          .                 return;
          .             }
150,000,000 (1.6%)      stack_push(PTR_STACK, p);
          .         
          .             log_info("ptr_stack_push(...) == void");
 60,000,000 (0.6%)  }
          .         
          .         void ptr_stack_scope_end()
 40,000,004 (0.4%)  {
          .             log_trace("scope end");
          .             log_info("ptr_stack_scope_end()");
          .         
 30,000,000 (0.3%)      while (true) {
120,000,003 (1.2%)          void **p = _ptr_stack_pop();
 80,000,002 (0.8%)          if (p == PTR_STACK_SENTINEL)
 10,000,001 (0.1%)              break;
          .                 gc_deregister(*p);
          .             }
          .         
          .             log_info("ptr_stack_scope_end(...) == void");
 30,000,003 (0.3%)  }
          .         
          .         static void **_ptr_stack_pop()
160,000,004 (1.7%)  {
          .             log_info("_ptr_stack_pop()");
          .         
160,000,004 (1.7%)      void **p = stack_pop(PTR_STACK);
          .         
          .             log_info("_ptr_stack_pop() == %p", p);
 40,000,001 (0.4%)      return p;
 80,000,002 (0.8%)  }
          .         
          .         #endif

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/stack.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 23 ----------------------------------------
          .         
          .         static void _stack_grow(stack_t * s);
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         stack_t *stack_init(size_t initial_size)
          5 (0.0%)  {
          3 (0.0%)      stack_t *s = malloc(sizeof(stack_t));
          .         
          3 (0.0%)      s->max_size = initial_size;
          2 (0.0%)      s->top = 0;
          7 (0.0%)      s->items = malloc(sizeof(void **) * initial_size);
          .         
          1 (0.0%)      return s;
          2 (0.0%)  }
          .         
          .         void stack_push(stack_t *s, void **p)
240,000,006 (2.5%)  {
240,000,006 (2.5%)      if (s->top == s->max_size)
          .                 _stack_grow(s);
440,000,011 (4.6%)      s->items[s->top++] = p;
120,000,003 (1.2%)  }
          .         
          .         void **stack_pop(stack_t *s)
200,000,005 (2.1%)  {
160,000,004 (1.7%)      if (s->top == 0) {
          .                 log_error("Tried to stack_pop with top == 0");
          .                 exit(1);
          .             }
480,000,012 (5.0%)      return s->items[--s->top];
 80,000,002 (0.8%)  }
          .         
          .         void stack_drop(stack_t *s)
          .         {
          .             free(s->items);
          .             free(s);
          .         }
          .         
          .         static void _stack_grow(stack_t *s)
-- line 63 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/../../../include/trc.h
--------------------------------------------------------------------------------
Ir________________ 

-- line 32 ----------------------------------------
          .         static void _trc_push_to_search_stack(void *p);
          .         
          .         // ==============================================
          .         // Definitions
          .         // ==============================================
          .         
          .         
          .         void trc_init()
          3 (0.0%)  {
          2 (0.0%)      alloc_init();
          3 (0.0%)  }
          .         
          .         void trc_alloc(void **p, size_t size,
          .                        void (*map_ptrs)(void *, void(*f)(void *)))
140,000,000 (1.5%)  {
 40,000,000 (0.4%)      if (p == NULL) {
          .                 log_error
          .                     ("Passed NULL to trc_alloc (did you mean to pass &p instead of p?)");
          .                 exit(1);
          .             }
100,000,000 (1.0%)      _trc_header_t *header = alloc_new(size + sizeof(intptr_t));
 40,000,000 (0.4%)      if (header == NULL) {
          .                 trc_collect();
          .                 header = alloc_new(size + sizeof(intptr_t));
          .                 if (header == NULL) {
          .                     log_error("Failed to allocate a block of size %ld", size);
          .                     exit(1);
          .                 }
          .             }
 60,000,000 (0.6%)      header->map_ptrs = map_ptrs;
 80,000,000 (0.8%)      *p = header + 1;
          .             log_trace("a %p", *p);
 60,000,000 (0.6%)  }
          .         
          .         void trc_collect()
          .         {
          .             _trc_mark();
          .             _trc_sweep();
          .         }
          .         
          .         // from the root set, dfs using map_ptrs 
-- line 72 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/madi/cosc490/cgc/test/bench/inf_chain/main.c
--------------------------------------------------------------------------------
Ir_______________ 

-- line 8 ----------------------------------------
         .             struct list *tail;
         .         } list_t;
         .         
         .         void list_t__map_ptrs(list_t *a, void (*f)(void *))
         .         {
         .             (*f) (a->tail);
         .         }
         .         
70,000,000 (0.7%)  void iterate() {
60,000,000 (0.6%)      cgc_scope_start();
         .         
40,000,000 (0.4%)      cgc_scope_declare(list_t *, a);
70,000,000 (0.7%)      cgc_alloc(&a, list_t);
         .             
40,000,000 (0.4%)      cgc_scope_declare(list_t*, b);
70,000,000 (0.7%)      cgc_alloc(&b, list_t);
         .             
40,000,000 (0.4%)      cgc_scope_declare(list_t*, c);
         .             //cgc_alloc(&c, list_t);
         .         
80,000,000 (0.8%)      cgc_assign(&a->tail, b);
80,000,000 (0.8%)      cgc_assign(&b->tail, c);
         .         
60,000,000 (0.6%)      cgc_scope_end();
30,000,000 (0.3%)      cgc_free(a);
30,000,000 (0.3%)      cgc_free(b);
         .             //cgc_free(c);
10,000,000 (0.1%)      return;
50,000,000 (0.5%)  }
         .         
         7 (0.0%)  int main() {
         8 (0.0%)      cgc_scope_start();
         .         
         1 (0.0%)      int total_iterations  = 10000000;
         1 (0.0%)      int target_recordings = 1000;
         4 (0.0%)      int threshold = total_iterations / target_recordings;
         .         
40,000,005 (0.4%)      for (int i = 0; i < total_iterations; i++) {
20,000,000 (0.2%)          iterate();
60,000,000 (0.6%)          if (i % threshold == 0) {
     6,000 (0.0%)              cgc_monitor_write_user("progress,%d\n", i);
         .                 }
         .             }
         8 (0.0%)      cgc_scope_end();
         1 (0.0%)      return 0;
         5 (0.0%)  

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir___________________ 

9,342,569,424 (97.1%)    annotated: files known & above threshold & readable, line numbers known
            0            annotated: files known & above threshold & readable, line numbers unknown
            0          unannotated: files known & above threshold & two or more non-identical
  240,256,048  (2.5%)  unannotated: files known & above threshold & unreadable 
      165,179  (0.0%)  unannotated: files known & below threshold
   40,019,891  (0.4%)  unannotated: files unknown

